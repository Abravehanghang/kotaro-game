<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>小太郎の大冒险</title>
    <style>
        * {
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            border: none;
            overflow: hidden;
            background: linear-gradient(180deg, #87CEEB 0%, #4682B4 50%, #001f3f 100%);
            touch-action: none;
        }
        @media (max-width: 768px) and (orientation: portrait) {
            #gameContainer { width: 100vw; height: 100vh; }
        }
        @media (max-width: 768px) and (orientation: landscape) {
            #gameContainer { width: 100vw; height: 100vh; }
        }
        @media (min-width: 769px) {
            #gameContainer { max-height: 600px; border-radius: 15px; box-shadow: 0 0 20px rgba(135, 206, 235, 0.5); }
        }
        #gameCanvas {
            display: block;
            background: transparent;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* UI层不接受点击，交给gameContainer统一处理 */
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            background: rgba(0, 25, 51, 0.7);
            backdrop-filter: blur(5px);
            z-index: 20;
            pointer-events: auto; /* 屏幕层可以接收点击 */
        }
        #startScreen h1 {
            font-size: 48px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        #startScreen p, #gameOver p {
            font-size: 18px;
            margin-top: 0;
        }
        .button-container {
            margin-top: 20px;
        }
        .button {
            background-color: #ff9800;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px #e68a00;
            transition: all 0.1s ease;
            margin: 0 10px;
        }
        .button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #e68a00;
        }
        #gameOver { display: none; }
        #finalMessage, #loveMessage { display: none; }
        #medal {
            font-size: 60px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="score">得分: 0</div>
            <div id="loveMessage" class="screen" style="pointer-events: none;">
                <h1>爱你宝宝 ❤️</h1>
            </div>
        </div>
        <div id="startScreen" class="screen">
            <h1>小太郎の大冒险</h1>
            <p>点击或触摸屏幕开始</p>
        </div>
        <div id="gameOver" class="screen">
            <h1>游戏结束</h1>
            <div id="medal"></div>
            <p id="finalScore"></p>
            <div class="button-container">
                <button id="restartButton" class="button">再玩一次</button>
                <button id="menuButton" class="button">返回主菜单</button>
            </div>
        </div>
        <div id="finalMessage" class="screen">
            <h1>恭喜通关!</h1>
            <p>请联系制作者领取神秘礼物🎁</p>
        </div>
    </div>

    <!-- 音乐文件 -->
    <audio id="bgm-menu" loop src="gymnopedie"></audio>
    <audio id="bgm-game" loop src="arabesque"></audio>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        const scoreEl = document.getElementById('score');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const finalMessage = document.getElementById('finalMessage');
        const loveMessage = document.getElementById('loveMessage');
        const restartButton = document.getElementById('restartButton');
        const menuButton = document.getElementById('menuButton');
        const medalEl = document.getElementById('medal');
        
        const bgmMenu = document.getElementById('bgm-menu');
        const bgmGame = document.getElementById('bgm-game');

        let isGameOver = false, gameStarted = false, hasShield = false;
        let score = 0, frame = 0, difficultyLevel = 0;
        let audioUnlocked = false;

        let W, H; // Canvas dimensions in CSS pixels

        let otter = {}, seaweeds = [], collectibles = [], backgroundRocks = [];

        const settings = {
            gravity: 0.18,
            jumpStrength: -4.5,
            otterSize: 30,
            seaweed: {
                width: 50,
                minGap: 150, 
                maxGap: 250
            },
            collectibles: {
                size: 15,
                chance: 0.6,
                starChance: 0.15,
                heartSize: 20
            },
            difficulty: [
                { score: 0,  speed: 1.8, interval: 150 }, // 0-50
                { score: 50, speed: 2.1, interval: 130 }, // 51-80
                { score: 80, speed: 2.4, interval: 110 }  // 81+
            ],
            rock: {
                count: 10,
                minSize: 20,
                maxSize: 60,
                minSpeed: 0.1,
                maxSpeed: 0.3
            }
        };
        let currentDifficulty = settings.difficulty[0];

        function setupCanvas() {
            const rect = gameContainer.getBoundingClientRect();
            W = rect.width;
            H = rect.height;

            const dpr = window.devicePixelRatio || 1;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = `${W}px`;
            canvas.style.height = `${H}px`;
            
            ctx.scale(dpr, dpr);
        }

        function init() {
            isGameOver = false;
            gameStarted = true;
            score = 0;
            frame = 0;
            hasShield = false;
            difficultyLevel = 0;
            currentDifficulty = settings.difficulty[0];

            otter = {
                x: 80,
                y: H / 2,
                vy: 0,
                width: settings.otterSize,
                height: settings.otterSize
            };
            seaweeds = [];
            collectibles = [];

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            finalMessage.style.display = 'none';
            scoreEl.style.display = 'block';
            updateScore();
            
            bgmMenu.pause();
            bgmGame.currentTime = 0;
            bgmGame.play().catch(e => console.error("Game BGM failed to play:", e));
        }

        function resetToMenu() {
            isGameOver = false;
            gameStarted = false;
            scoreEl.style.display = 'none';
            startScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            finalMessage.style.display = 'none';
            
            bgmGame.pause();
            bgmMenu.currentTime = 0;
            bgmMenu.play().catch(e => console.error("Menu BGM failed to play:", e));
        }

        function startGame() {
            if (!gameStarted) {
                init();
                gameLoop();
            }
        }
        
        function unlockAudio() {
            if (audioUnlocked) return;
            bgmMenu.play().catch(()=>{});
            bgmGame.play().catch(()=>{});
            audioUnlocked = true;
            resetToMenu();
        }

        function jump() {
            if (!isGameOver) {
                otter.vy = settings.jumpStrength;
            }
        }

        function handleInteraction(event) {
            // For touch, prevent default browser actions like scrolling
            if (event.type === 'touchstart') {
                event.preventDefault();
            }

            // If the target is a button, let its own event listener handle it
            if (event.target.tagName === 'BUTTON') {
                return;
            }

            // Unlock audio on the very first interaction
            if (!audioUnlocked) {
                unlockAudio();
                return; // The first tap is only for unlocking audio and showing menu
            }

            if (isGameOver) return;
            
            if (!gameStarted) {
                startGame();
            }
            jump();
        }

        function updateDifficulty() {
            let newLevel = 0;
            if (score > settings.difficulty[2].score) {
                newLevel = 2;
            } else if (score > settings.difficulty[1].score) {
                newLevel = 1;
            }
            if (newLevel !== difficultyLevel) {
                difficultyLevel = newLevel;
                currentDifficulty = settings.difficulty[difficultyLevel];
            }
        }

        function createSeaweed(isHeartChallenge = false) {
            const gap = isHeartChallenge ? H * 0.5 : Math.random() * (settings.seaweed.maxGap - settings.seaweed.minGap) + settings.seaweed.minGap;
            const minHeight = 50;
            const availableHeight = H - gap - (minHeight * 2);
            
            const topHeight = minHeight + Math.random() * availableHeight;
            const bottomHeight = H - topHeight - gap;

            seaweeds.push({ x: W, y: 0, width: settings.seaweed.width, height: topHeight, passed: false });
            seaweeds.push({ x: W, y: H - bottomHeight, width: settings.seaweed.width, height: bottomHeight, passed: false });
            
            if (isHeartChallenge) {
                for (let i = 0; i < 3; i++) {
                    collectibles.push({
                        x: W + settings.seaweed.width / 2,
                        y: topHeight + (gap / 4) * (i + 1),
                        type: 'heart',
                        size: settings.collectibles.heartSize
                    });
                }
            } else if (Math.random() < settings.collectibles.chance) {
                const itemType = Math.random() < settings.collectibles.starChance ? 'star' : 'fish';
                collectibles.push({
                    x: W + settings.seaweed.width,
                    y: topHeight + gap / 2,
                    type: itemType,
                    size: settings.collectibles.size,
                    vx: (Math.random() - 0.5) * 2, // -1 to 1
                    vy: (Math.random() - 0.5) * 2
                });
            }
        }
        
        function createBackgroundRocks() {
            backgroundRocks = [];
            for (let i = 0; i < settings.rock.count; i++) {
                backgroundRocks.push({
                    x: Math.random() * W,
                    y: H - Math.random() * (H / 4),
                    size: Math.random() * (settings.rock.maxSize - settings.rock.minSize) + settings.rock.minSize,
                    speed: Math.random() * (settings.rock.maxSpeed - settings.rock.minSpeed) + settings.rock.minSpeed,
                    opacity: 0.1 + Math.random() * 0.4
                });
            }
        }

        function update() {
            if (isGameOver) return;
            frame++;
            
            // Otter physics
            otter.vy += settings.gravity;
            otter.y += otter.vy;

            // Check boundaries
            if (otter.y + otter.height / 2 > H || otter.y - otter.height / 2 < 0) {
                return gameOver();
            }

            // Update seaweed
            if (frame % currentDifficulty.interval === 0) {
                 if (score === 21) {
                    createSeaweed(true);
                } else {
                    createSeaweed();
                }
            }

            for (let i = seaweeds.length - 1; i >= 0; i--) {
                const s = seaweeds[i];
                s.x -= currentDifficulty.speed;

                // Collision check
                if (otter.x < s.x + s.width && otter.x + otter.width > s.x &&
                    otter.y < s.y + s.height && otter.y + otter.height > s.y) {
                    if (hasShield) {
                        hasShield = false;
                        seaweeds.splice(i, 1); // Destroy seaweed
                    } else {
                        return gameOver();
                    }
                }

                if (s.x + s.width < otter.x && !s.passed) {
                    s.passed = true;
                    // Score is added for every pair of seaweeds passed
                    if(seaweeds.filter(sw => sw.passed).length % 2 === 0) {
                        score++;
                        updateScore();
                        updateDifficulty();
                    }
                }
                
                if (s.x + s.width < 0) {
                    seaweeds.splice(i, 1);
                }
            }
            
            // Update collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const item = collectibles[i];
                item.x -= currentDifficulty.speed;
                
                if (item.type === 'fish') {
                    item.y += item.vy;
                    if (item.y < 0 || item.y > H) item.vy *= -1;
                }

                const distX = (otter.x + otter.width / 2) - item.x;
                const distY = (otter.y + otter.height / 2) - item.y;
                if (Math.sqrt(distX * distX + distY * distY) < otter.width / 2 + item.size / 2) {
                    switch (item.type) {
                        case 'fish': score += 1; break;
                        case 'star': hasShield = true; break;
                        case 'heart': score += 5; break;
                    }
                    collectibles.splice(i, 1);
                    updateScore();
                    updateDifficulty();
                } else if (item.x + item.size < 0) {
                    collectibles.splice(i, 1);
                }
            }

            // Check for 21-point message
            if (score >= 21 && score < 26) { // Show for a few points
                loveMessage.style.display = 'flex';
            } else {
                loveMessage.style.display = 'none';
            }
            
            // Check for 100-point win
            if (score >= 100) {
                return gameOver(true);
            }
        }
        
        function updateScore() {
            scoreEl.textContent = `得分: ${score}`;
        }

        function draw() {
            ctx.clearRect(0, 0, W, H);
            
            // Draw background rocks
            backgroundRocks.forEach(rock => {
                rock.x -= rock.speed;
                if (rock.x + rock.size < 0) {
                    rock.x = W + rock.size;
                }
                ctx.fillStyle = `rgba(0, 0, 0, ${rock.opacity})`;
                ctx.beginPath();
                ctx.arc(rock.x, rock.y, rock.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw otter
            ctx.save();
            ctx.translate(otter.x + otter.width / 2, otter.y + otter.height / 2);
            ctx.rotate(Math.PI / 180 * (otter.vy * 5));
            ctx.fillStyle = '#D2B48C'; // Tan color for otter
            ctx.fillRect(-otter.width / 2, -otter.height / 2, otter.width, otter.height);
            ctx.restore();
            
            if (hasShield) {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(otter.x + otter.width/2, otter.y + otter.height/2, otter.width, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw seaweeds
            seaweeds.forEach(s => {
                ctx.fillStyle = '#2E8B57'; // SeaGreen
                ctx.fillRect(s.x, s.y, s.width, s.height);
            });
            
            // Draw collectibles
            collectibles.forEach(item => {
                 ctx.font = `${item.size}px Arial`;
                 let symbol = '';
                 switch(item.type) {
                     case 'fish': symbol = '🐟'; break;
                     case 'star': symbol = '⭐'; break;
                     case 'heart': symbol = '❤️'; break;
                 }
                 ctx.fillText(symbol, item.x - item.size/2, item.y + item.size/2);
            });
        }
        
        function getMedal(s) {
            if (s > 90) return '💎'; // Diamond
            if (s > 70) return '🥇'; // Gold
            if (s > 40) return '🥈'; // Silver
            if (s > 10) return '🥉'; // Bronze
            return '🐠'; // Fish
        }

        function gameOver(isWin = false) {
            if (isGameOver) return;
            isGameOver = true;
            gameStarted = false;
            
            bgmGame.pause();

            if (isWin) {
                finalMessage.style.display = 'flex';
            } else {
                gameOverScreen.style.display = 'flex';
                finalScoreEl.textContent = `最终得分: ${score}`;
                medalEl.textContent = getMedal(score);
            }
        }
        
        function gameLoop() {
            update();
            draw();
            if (!isGameOver) {
                requestAnimationFrame(gameLoop);
            }
        }

        // --- Event Listeners ---
        window.addEventListener('resize', setupCanvas);
        
        // Use a single handler for starting game and jumping
        gameContainer.addEventListener('click', handleInteraction);
        gameContainer.addEventListener('touchstart', handleInteraction, { passive: false });

        // Separate, explicit listeners for buttons
        restartButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Stop event from bubbling to container
            init();
            gameLoop();
        });
        
        menuButton.addEventListener('click', (e) => {
            e.stopPropagation();
            resetToMenu();
        });

        // --- Initial Setup ---
        setupCanvas();
        createBackgroundRocks();
        resetToMenu();
    </script>
</body>
</html>
